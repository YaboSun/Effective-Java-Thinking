本章主题就是创建和销毁对象：  
* 何时以及如何创建对象  
* 何时以及如何避免创建对象  
* 如何确定能够适时销毁  
* 如何管理对象销毁之前必须进行的各项清理动作  
  
主要参考：《Effective Java》第二版 第二章、https://blog.csdn.net/hzy38324/article/details/72630415  
  
# 什么是静态工厂方法  
对于类而言，为了让使用者获取它自身的一个实例，最常用的方法就是提供一个公有的构造器。  
当然，这里要介绍的是另一种方法——静态工厂方法，一个返回类的实例的静态方法。  

# 提供静态工厂方法而不是公有构造器的优势：  
1. 具名（有名称）  
* 如果构造器的参数本身没有确切的描述正被返回的对象，那么具有名称的静态工厂更容易使用，产生的代码也更容易阅读。  
* 另外一个问题就是，一个类只能指定一个带有指定签名的构造器，但是一般情况下会有多种返回结果，所以一般的处理情况就是改变构造器参数的顺序，  
这样给用户提供的API就很容易调用错误的构造器，调用时候就会一头雾水，而这时候使用静态工厂方法就可以避免这个，只需提供准确的名称就可以一眼看出需要的功能。
  
2. 环保
指的是相对于构造器来说不用每次都创建一个新对象，详细的理解可以参考代码中SimpleFactoryPattern的说明及实现  

3. 多子  
指可以返回原返回类型的任何子类型的对象，详细可以参考EnumSet中的noneOf代码实现

4. 简化代码
在创建参数化实例类型的时候，如果是调用参数化类的构造器，即使参数类型很明显，也必须指出，通常要求你接连俩次提供类型参数（后续版本的jdk简化了）  
比如：
```Java
Map<String, List<String>> m = new HashMap<String, List<String>>();
```
而假设HashMap提供了这个静态工厂：
```Java
public static <K, V> HashMap<K, V> newInstance() {
    return new HashMap<K, V>();
    }
```
那么就可以使用以下简洁的代码代替上面的复杂代码：
```Java
Map<String, List<String>> m = HashMap.newInstance();
```  

# 静态工厂方法的缺点  
1. 类如果不含公有的或受保护的构造器，就不能被子类化  

2. 静态工厂方法与其他静态方法实际上没有任何区别
  
# 静态工厂方法的惯用名称  
* valueOf---不太严格的讲，该方法返回的实例与它的参数具有相同的值，这样的静态工厂方法实际上是类型转换方法  
* of---valueOf的一种更为简介的替代，在EnumSet中使用并流行起来
* getInstance---返回的实例是通过方法的参数来描述的，但是不能说与参数具有相同的值
* newInstance---像getInstance一样，但newInstance能够确保返回的每个实例都与所有其他实例不同
* getType---像getInstance一样，但是在工厂方法处于不同的类中的时候使用  
type表示工厂方法返回的对象类型
* newType---像newInstance一样，但是在工厂方法处于不同的类中的时候使用  
type表示工厂方法返回的对象类型
  
# 总结
简单来说，这俩个各有用处，应该理解各自的长处，但是实际用过程中，我现在第一想法还是通过提供共有的构造器，  
以后应该改变这个想法，优先考虑静态工厂方法

