package factory.factorymethod;

/**
 * @author  YaboSun
 * @since  Created in 18-10-17
 *
 * 工厂方法模式接口
 * 实现工厂方法模式，主要是为了与静态工厂方法进行区分
 *
 * 简单工厂模式缺点：
 * 要在这个简单工厂类里编写很多个方法，每个方法里是不是得写很多相应的业务代码，
 * 而每次增加子类或者删除子类对象的创建是不是都需要打开这简单工厂类来进行修改
 * 这不就很明显的会导致这个简单工厂类很庞大臃肿、耦合性高，而且增加、删除某个
 * 子类对象的创建都需要打开简单工厂类来进行修改代码也违反了开-闭原则，如这是
 * 客户端代码还好说，但简单工厂类也算是一个功能类，所以不能随便就去修改它
 *
 * 所以有了工厂方法模式，
 * 相对于简单工厂模式进一步解耦，因为在工厂方法模式中是一个子类对应一个工厂类，
 * 而这些工厂类都实现于一个抽象接口。这相当于是把原本会因为业务代码而庞大的简
 * 单工厂类，拆分成了一个个的工厂类，这样代码就不会都耦合在同一个类里了，就像
 * 把一个大蛋糕切成了多个小蛋糕
 *
 * 工厂方法模式主要角色：
 * Factory： 工厂接口
 * ConcreteFactory: 具体的工厂类，实现工厂接口
 * Product： 产品接口
 * ConcreteProduct: 具体的产品类，实现产品接口
 *
 * 以一个四则运算的案例来进行说明，整个代码的结构位于resources目录
 */
public interface FactoryMethodPattern {
    Operation createOperation();
}
